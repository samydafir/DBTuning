\documentclass[11pt]{scrartcl}

\usepackage[top=2cm]{geometry}
%\pagestyle{empty}

\title{
  \textbf{\large Database Tuning -- Assignment 5}\\
  Join Tuning
}


\author{
A2\\
\large Baumgartner Dominik, 0920177 \\
\large Dafir Thomas Samy, 1331483 \\
\large Sch\"orgnhofer Kevin, 1421082
}

\begin{document}

\maketitle
\section{setup}
All queries were sent to the database-server (biber) using $psql$ on the computers of the R\"UR.

\section{Join Strategies Proposed by System}

\paragraph{Response times}

\begin{flushleft}
\begin{tabular}{l|l|l}
  Indexes & Join Strategy Q1 & Join Strategy Q2\\
  \hline
  no index & Hash Join & Hash Join  \\
  unique non-clustering on {\tt Publ.pubID} & Hash Join  & Nested Loop Join \\
  clustering on {\tt Publ.pubID} and {\tt Auth.pubID} & Merge Join & Nested Loop Join \\
\end{tabular}
\end{flushleft}

\paragraph{Discussion}
Discuss here your observations. Is the choice of the strategy
expected? How does the system come to this choice?\\
no index:\\
For this scenario the proposed join strategies are the expected ones. A hash join is in this case the best choice. For a merge join the tables should be sorted and the nested loop join should be used when there is a small table.\\
\\
unique non-clustering on {\tt Publ.pubID}:\\
For the first query a hash join is the best choice, because of the big, unsorted table of both. For this query the index is of no use.\\
For the second query a Nested Loop Join is used because first the name from the author must be searched which reduces the table size from $3*10^6$ to $\sim$200. Thereforce the nested loop join is the better choice.\\
\\
clustering on {\tt Publ.pubID} and {\tt Auth.pubID}:\\
For the first query a Merge Join is proposed as expected. The reason therefore is that both tables are sorted to this attribute which is ideal for the Merge Join.\\
For the second query we expected a Merge Join, but the system used a Nested Loop Join. The Reason therefore is again the table size. First the name is searched in Auth which reduces the size and also "destroys" the ordering. This means that the system would have to sort the values again for the Merge Join although the values are still sorted. And therefore a Nested Loop Join is the best choice.


\section{Nested Loop Join}

\paragraph{Response times}

\begin{flushleft}
\begin{tabular}{l|r|r}
  Indexes & Response time Q1 [ms] & Response time Q2 [ms] \\
  \hline
  index on {\tt Publ.pubID} & ... & ...  \\
  index on {\tt Auth.pubID} & ... & ... \\
  index on {\tt Publ.pubID} and {\tt Auth.pubID} & ...& ... \\
\end{tabular}
\end{flushleft}

\paragraph{Query plans}\mbox{}\\ 

\noindent Index on {\tt Publ.pubID} (Q1/Q2):
{\small
\begin{verbatim}
query plans (index on Publ.pubID)
\end{verbatim}
}

\noindent Index on {\tt Auth.pubID} (Q1/Q2):
{\small
\begin{verbatim}
query plans (index on Auth.pubID)
\end{verbatim}
}

\noindent Index on {\tt Auth.pubID} and {\tt Auth.pubID} (Q1/Q2):
{\small
\begin{verbatim}
query plans (indexes on Publ.pubID and Auth.pubID)
\end{verbatim}
}

\paragraph{Discussion}
Discuss here your observations. Are the response times expected? Why / why
not? 

\section{Sort-Merge Join}

\paragraph{Response times}

\begin{flushleft}
\begin{tabular}{l|r|r}
  Indexes & Response time Q1 [ms] & Response time Q2 [ms] \\
  \hline
  no index & too long & 27886 \\
  two non-clustering indexes & 37306 & 508 \\
  two clustering indexes & 18891 & 515  \\
\end{tabular}
\end{flushleft}

\paragraph{Query plans}\mbox{}\\ 

\noindent No index (Q1/Q2):
{\small
\begin{verbatim}
Q1:
Merge Join  (cost=846625.43..906956.29 rows=3095201 width=83)
   Merge Cond: ((publ.pubid)::text = (auth.pubid)::text)
   ->  Sort  (cost=285913.35..288996.38 rows=1233214 width=90)
         Sort Key: publ.pubid
         ->  Seq Scan on publ  (cost=0.00..34694.14 rows=1233214 width=90)
   ->  Materialize  (cost=560711.47..576187.47 rows=3095201 width=38)
         ->  Sort  (cost=560711.47..568449.47 rows=3095201 width=38)
               Sort Key: auth.pubid
               ->  Seq Scan on auth  (cost=0.00..57750.01 rows=3095201 width=38)

Q2:
Merge Join  (cost=351419.92..357590.96 rows=413 width=68) 
	    (actual time=24054.639..27857.060 rows=183 loops=1)
   Merge Cond: ((publ.pubid)::text = (auth.pubid)::text)
   ->  Sort  (cost=285913.35..288996.38 rows=1233214 width=90) 
             (actual time=23183.951..26169.586 rows=1229958 loops=1)
         Sort Key: publ.pubid
         Sort Method: external merge  Disk: 121400kB
         ->  Seq Scan on publ  (cost=0.00..34694.14 rows=1233214 width=90) 
                               (actual time=0.026..850.908 rows=1233214 loops=1)
   ->  Sort  (cost=65505.96..65506.99 rows=413 width=23) 
	     (actual time=519.464..519.550 rows=183 loops=1)
         Sort Key: auth.pubid
         Sort Method: quicksort  Memory: 39kB
         ->  Seq Scan on auth  (cost=0.00..65488.01 rows=413 width=23) 
                               (actual time=8.420..518.464 rows=183 loops=1)
               Filter: ((name)::text = 'Divesh Srivastava'::text)
               Rows Removed by Filter: 3095018
 Planning time: 0.351 ms
 Execution time: 27886.590 ms
\end{verbatim}
}

\noindent Two non-clustering indexes (Q1/Q2):
{\small
\begin{verbatim}
Q1:
Merge Join  (cost=0.86..263625.34 rows=3095201 width=83) 
            (actual time=0.038..36048.698 rows=3095201 loops=1)
   Merge Cond: ((publ.pubid)::text = (auth.pubid)::text)
   ->  Index Scan using pubidpubl on publ  (cost=0.43..73055.43 rows=1233214 width=90) 
					   (actual time=0.006..6608.030 rows=1233208 loops=1)
   ->  Index Scan using pubidauth on auth  (cost=0.43..148974.61 rows=3095201 width=38) 
				           (actual time=0.005..13439.998 rows=3095201 loops=1)
 Planning time: 0.768 ms
 Execution time: 37306.638 ms

Q2:
Merge Join  (cost=65499.99..141460.64 rows=24 width=68) 
	    (actual time=508.011..508.011 rows=0 loops=1)
   Merge Cond: ((publ.pubid)::text = (auth.pubid)::text)
   ->  Index Scan using pubidpubl on publ  (cost=0.43..73055.43 rows=1233214 width=90) 
					   (actual time=0.006..0.006 rows=1 loops=1)
   ->  Sort  (cost=65499.56..65499.62 rows=24 width=23) 
	     (actual time=508.002..508.002 rows=0 loops=1)
         Sort Key: auth.pubid
         Sort Method: quicksort  Memory: 25kB
         ->  Seq Scan on auth  (cost=0.00..65499.01 rows=24 width=23) 
			       (actual time=507.995..507.995 rows=0 loops=1)
               Filter: ((name)::text = 'Divesh Srivastav'::text)
               Rows Removed by Filter: 3095201
 Planning time: 0.528 ms
 Execution time: 508.045 ms
\end{verbatim}
}

\noindent Two clustering indexes  (Q1/Q2):
{\small
\begin{verbatim}
Q1:
Merge Join  (cost=0.86..263629.21 rows=3095201 width=83) 
	    (actual time=0.022..17687.042 rows=3095201 loops=1)
   Merge Cond: ((publ.pubid)::text = (auth.pubid)::text)
   ->  Index Scan using pubidpubl on publ  (cost=0.43..73057.97 rows=1233214 width=90) 
					   (actual time=0.005..917.866 rows=1233208 loops=1)
   ->  Index Scan using pubidauth on auth  (cost=0.43..148975.94 rows=3095201 width=38) 
					   (actual time=0.004..2033.002 rows=3095201 loops=1)
 Planning time: 0.606 ms
 Execution time: 18891.404 ms

Q2:
Merge Join  (cost=65500.99..141464.18 rows=24 width=68) 
	    (actual time=515.935..515.935 rows=0 loops=1)
   Merge Cond: ((publ.pubid)::text = (auth.pubid)::text)
   ->  Index Scan using pubidpubl on publ  (cost=0.43..73057.97 rows=1233214 width=90) 
    				           (actual time=0.006..0.006 rows=1 loops=1)
   ->  Sort  (cost=65500.56..65500.62 rows=24 width=23) 
	     (actual time=515.926..515.926 rows=0 loops=1)
         Sort Key: auth.pubid
         Sort Method: quicksort  Memory: 25kB
         ->  Seq Scan on auth  (cost=0.00..65500.01 rows=24 width=23) 
                               (actual time=515.919..515.919 rows=0 loops=1)
               Filter: ((name)::text = 'Divesh Srivastav'::text)
               Rows Removed by Filter: 3095201
 Planning time: 0.535 ms
 Execution time: 515.970 ms
\end{verbatim}
}

\paragraph{Discussion}
Discuss here your observations. Are the response times expected? Why
/ why not? 

\section{Hash Join}

\paragraph{Response times}

\begin{flushleft}
\begin{tabular}{l|r|r}
  Indexes & Response time Q1 [ms] & Response time [ms] Q2 \\
  \hline
  no index & ... & ... \\
\end{tabular}
\end{flushleft}

\paragraph{Query plans}\mbox{}\\ 

\noindent No Index (Q1/Q2):
{\small
\begin{verbatim}
query plans (no index)
\end{verbatim}
}

\paragraph{Discussion}

What do you think about the response time of the hash index vs.\ the
response times of sort-merge and index nested loop join for each of
the queries? Explain.

\bigskip

\noindent Time in hours per person: {\bf XXX}

\bigskip

\begin{center}
  \begin{tabular}{c}
    \hline
    {\bf Important:} Reference your information sources!
    \\\hline
  \end{tabular}
\end{center}

\end{document}
